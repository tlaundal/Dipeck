allprojects {
  ext.nodejs = false
  ext.compose = false
}

task clean(type: Delete) {
  delete buildDir
}

subprojects { afterEvaluate { project -> if (project.compose) {
  task composeBuild(type: Exec) {
    executable "docker-compose"
    args "build", project.compose
  }

  task composeUp(type: Exec) {
    dependsOn composeBuild

    executable "docker-compose"
    args "up", "-d", project.compose
  }

  task composeStop(type: Exec) {
    mustRunAfter composeUp

    executable "docker-compose"
    args "stop", project.compose
  }

  task composeDown(type: Exec) {
    dependsOn composeStop

    executable "docker-compose"
    args "rm", "-f", "-v", project.compose
  }
}}}

task composeDown(type: Exec) {
  subprojects.each { child -> child.afterEvaluate { if (child.compose) {
    dependsOn child.tasks.composeDown
  } } }

  executable "docker-compose"
  args "down"
}

task composeUpFreshVolumes(type: Exec) {
  subprojects.each { child -> child.afterEvaluate { if (child.compose) {
    dependsOn child.tasks.composeBuild
  }}}

  executable "docker-compose"
  args "up", "-d", "--renew-anon-volumes"
}

/**
 * Configure node projects with a default config.
 */
subprojects { afterEvaluate { project -> if (project.nodejs) {
  task cleanWorkspace(type: Delete) {
    delete "node_modules"
  }

  task clean(type: Delete) {
    delete buildDir
  }

  task npmDependencies(type: Exec) {
    inputs.file "package.json"
    outputs.dir "node_modules"
    outputs.file "package-lock.json"

    executable "npm"
    args "install"
  }

  task mocha(type: Exec, dependsOn: npmDependencies) {
    if (sources) {
      inputs.dir sources
    }
    inputs.dir tests

    def reportPath = "${buildDir}/test-results/test/TEST-${project.name}.xml"

    outputs.file reportPath

    executable "./node_modules/.bin/mocha"
    args tests,
         "--reporter", "mocha-junit-reporter",
         "--reporter-options", "mochaFile=${reportPath}"
  }

  if (!project.tasks.findByName('test')) {
    task test (dependsOn: mocha)
  }
} } }

task collectReports(type: Copy) {
  include "TEST-*.xml"

  subprojects.each { child ->
    def path = "${child.buildDir}/test-results/test"
    inputs.dir path
    from path

    child.afterEvaluate {
      // Set a dependency from collectReports to this child's test task
      if (child.tasks.findByName('test')) {
        dependsOn child.tasks.test
      }
      if (child.tasks.findByName('integrationTest')) {
        mustRunAfter child.tasks.integrationTest
      }
    }
  }

  def path = "${buildDir}/test-reports/collected/"
  outputs.dir "${buildDir}/test-reports/collected/"
  into path
}

task combineReports(dependsOn: collectReports) {
  def output = file("${buildDir}/test-reports/combined.xml")
  inputs.dir "${buildDir}/test-reports/collected/"
  outputs.file output

  doLast {
    def slurper = new XmlSlurper()

    new groovy.xml.StreamingMarkupBuilder().bind {
      mkp.yield file("${buildDir}/test-reports/collected/").listFiles()
        .toList().stream()
        .map(slurper.&parse)
        // Flatten files with multiple testsuites
        .flatMap({ it?.testsuite.list().stream() ?: [it].stream() })
        // Only testsuites with testcases
        .filter({ !!it.testcase.size() })
        .collect({
          slurper.parseText '<testsuites name="Dipeck tests"></testsuites>'
        }, { a, b -> a.appendNode(b); a }, {})
    }.writeTo(output.newWriter())
  }
}

task renderReport(type: Exec, dependsOn: combineReports) {
  inputs.file "${buildDir}/test-reports/combined.xml"
  outputs.file "${buildDir}/test-reports/report.html"

  executable "xunit-viewer"
  args "--results=./build/test-reports/combined.xml",
       "--output=./build/test-reports/report.html"
}
